持久化
	两种方式RDB AOF
		RDB是按时间点进行内存快照 生成的二进制文件
		AOF是记录每次写操作的日志文件，append_only类型，可以后台重写日志文件(比如INCRBY一百次，重写后直接INCRBY 100即可)
		能完全关掉持久化功能，将redis做缓存用
		可以同时打开RDB AOF功能，重启时用AOF，因为AOF的数据最完整。
		RDB优点
			RDB文件是以时间为节点经过压缩的redis内存快照文件，用来做备份文件非常好
			适合用来做灾后重建，单个的压缩文件很适合做远程传输。
			RDB能最大化redis性能，只需要后台启动一个子进程就可以，子进程会做剩余工作。父进程不会有硬盘IO之类的操作
			相比AOF RDB允许更快的重启大数据集的redis
		RDB缺点
			由于RDB是按时间保存内存快照，redis异常停止工作时，总会丢失最近一段时间(上次快照到现在的)数据。
			RDB经常需要后台启动子进程来保存文件，如果数据量很大这个动作会很耗时，可能会导致redis服务停止响应(几毫秒甚至数秒钟)。而虽然AOF也需要后台启动进程，但可以调整重写日志频率，而不损失任何性能
		AOF优点
			用AOF更durable，能用不同的fsync策略：不fsync，每秒钟fsync，每次查询都fsync。默认配置每秒fsync一次，但是可能会丢失一秒钟的写数据(fsync是由后台线程)。
			AOF是append-only(追加写)，所以突然断电时也不损坏数据。即使aof文件中有写了一半的命令，redis-check-aof功能还是能轻易修复。
			当aof文件过大时，redis能后台自动重写aof文件。重写绝对安全(比如INCRBY一百次，重写后直接INCRBY 100即可)且不影响原aof继续写入。
			aof以很容易理解的方式记录日志，很容易导出，如果你不小心执行了FLUSHALL，只要aof文件没有重写，依然可以恢复数据，只需要停止redis服务，打开aof文件删除FLUSHALL命令，重启redis即可。
		AOF缺点
			通常，同样大小的数据备份AOF文件要大于RDB文件
			通常AOF比RDB慢，这也取决于fsync策略。总体来说，每秒一次fsync，性能还是很好，而关掉fsync，理论上性能应该和RDB一样。但是依然RDB方式更能保证低延迟，即使在大量写入情况下。
			在恢复数据时，虽然测试足够严格而且至今没有发现Bug，但aof依然是有可能出现bug的(必然的)。但RDB是快照绝对不会有bug。
	该用那种方式
		如果想要redis的数据安全性和PostgreSQL一个级别，应该RDB AOF两种方式一起配合使用
		如果在灾难情况下能接受几分钟的数据损失，可以只使用RDB。
		不鼓励单纯使用aof做备份，因为1)rdb以时间为节点做备份很好 2)rdb重启更快 3)aof不能排除出现bug的可能
		PS：由于以上原因，redis官方表示很可能将RDB AOF两种方式结合起来出现一种持久化模式，但这是长久计划，短期内呵呵……。
	快照Snapshotting
		redis将快照二进制文件默认保存在dump.rdb中，可以在配置文件中配置具体保存策略，或者可以通过SAVE or BGSAVE命令手动保存。
		如何工作：每当需要保存快照文件时，redis fork一个子进程，子进程向临时RDB文件中写数据，写完新的RDB文件后替换老文件。这种方式允许写时复制。
	AOF文件Append-only file
		快照方式连续性(durable)不是特别好,突然断电/kill -9最新的数据
	
搭建redis集群
	两种方式
		1/ 
			master--slave1
						|
						---slave2
		2/ 
			master--slave1--slave2

	搭建
		第一种方式
			master配置
				关闭rdb(由slave来备份)
					注释掉三个save即可
					#save 900 1
					#save 300 10
					#save 60 10000
				开启aof
					appendonly yes
				路径 放在安装目录的persist下
					dir ./persist
				配置密码(可选)
					################################## SECURITY ###################################
					requirepass **********
			slave配置
				声明slave-of
					slaveof localhost 6379
				配置密码(可选) 在REPLICATION下
					################################# REPLICATION #################################
					masterauth ********** #填入master的密码 设置密码后
				某个slave开启rdb功能
					6380开启rdb
				配置是否只读
					slave-read-only yes
				开启rdb修改rdb文件名和路径
					dir ./persist
					dbfilename dump6381.rdb
					dbfilename dump6380.rdb
				关闭aof功能 修改aof文件名
					appendonly no
					appendfilename "appendonly6380.aof"
					appendfilename "appendonly6381.aof"
			启动三台服务器
					redis-server redis.conf
					redis-server redis6380.conf
					redis-server redis6381.conf
			测试
				127.0.0.1:6379> set foo bar
				OK
				127.0.0.1:6380> keys *
				1) "foo"
				127.0.0.1:6381> get foo
				"bar"
				127.0.0.1:6381> set title hha
				(error) READONLY You can't write against a read only slave.
				
				OK
				要注意,虽然6379和6381都禁止了rdb功能，但依然生成了对应的rbd文件,但仔细看文件时间(如下)会发现dump6381.rdb和dump.rdb是相同时间生成的，我猜应该是6380执行的rdb工作，另外两台服务器只是将文件拷贝过去
					root@joshua-ubuntu:/usr/local/redis-4.0.8# ll persist/
					total 28
					drwxr-xr-x 2 root root 4096 Mar 22 17:40 ./
					drwxrwxr-x 7 root root 4096 Mar 22 17:39 ../
					-rw-r--r-- 1 root root   54 Mar 22 17:28 appendonly.aof
					-rw-r--r-- 1 root root  401 Mar 22 17:43 appendonly-test.aof
					-rw-r--r-- 1 root root  189 Mar 22 17:28 dump6380.rdb
					-rw-r--r-- 1 root root  189 Mar 22 17:29 dump6381.rdb
					-rw-r--r-- 1 root root  189 Mar 22 17:29 dump.rdb
				那如果配置三个服务器的rdb文件同名会不会拷贝呢，试以下
					1/ 单台服务器测试关闭rdb功能后是不会生成rdb文件的
					2/ 现在将三台服务器的rdb文件都改为dump.rdb,但只有6380开启rbd功能，执行一些写入操作，结果如下：
						root@joshua-ubuntu:/usr/local/redis-4.0.8# ll persist/
						total 20
						drwxr-xr-x 2 root root 4096 Mar 22 17:56 ./
						drwxrwxr-x 7 root root 4096 Mar 22 17:53 ../
						-rw-r--r-- 1 root root  368 Mar 22 17:57 appendonly.aof
						-rw-r--r-- 1 root root  401 Mar 22 17:43 appendonly-test.aof
						-rw-r--r-- 1 root root  189 Mar 22 17:56 dump.rdb
						root@joshua-ubuntu:/usr/local/redis-4.0.8#
				结论：这种简单集群环境下，各服务器rdb文件保持相同即可，不然会造成不必要的带宽浪费
			缺陷：
				每次slave断开后(无论主动断开还是网络异常)，再次连接master时都要master全部dump出rdb文件再aof，所以多台slave不要一下都启动起来
	集群其他配置项
		################################# REPLICATION #################################
		slave-priority 100 # 从机级别数字小级别高,在主机死掉的时候级别最高的代替主机,0：不允许做主机
		slave-serve-stale-data yes/no # slave和master断开时,是否允许用旧数据响应请求,数据可能已过期
		min-slaves-to-write 3 # 少于3太从服务器时，主机禁止写入
		min-slaves-max-lag 10 # 延迟超过10秒时，主机禁止写入
		操作
			copy两个配置文件命名为redis6380.conf  redis6381.conf作为从服务器的配置文件
			对应的修改配置我文件中端口为6380 和 6381

不小心操作了flushall/flushdb
	解决方案：赶紧shutdown nosave 删掉aof文件中最后的flush命令

通过rdb文件拷贝一个redis库
	直接拷贝rdb文件，将新库的rdb打开并将rdb文件指向拷贝后的文件，启动redis通过文件恢复即可
redis-check-rdb工具 检查rdb文件是否损坏
	root@josh-ubuntu:/usr/local/redis-4.0.8# redis-check-rdb ./rdb/dump6380.rdb 
	[offset 0] Checking RDB file ./rdb/dump6380.rdb
	[offset 26] AUX FIELD redis-ver = '4.0.8'
	[offset 40] AUX FIELD redis-bits = '64'
	[offset 52] AUX FIELD ctime = '1521738904'
	[offset 67] AUX FIELD used-mem = '1917088'
	[offset 85] AUX FIELD repl-stream-db = '0'
	[offset 135] AUX FIELD repl-id = '458f25b39165943d2e0f0cd7d98e254372d3f335'
	[offset 151] AUX FIELD repl-offset = '3193'
	[offset 167] AUX FIELD aof-preamble = '0'
	[offset 169] Selecting DB ID 0
	[offset 196] Checksum OK
	[offset 196] \o/ RDB looks OK! \o/
	[info] 2 keys read
	[info] 0 expires
	[info] 0 already expired


Sentinel-官方提供的高可用解决方案
	Monitoring：监控功能，Sentinel不断检查主从服务器是否正常工作
	Notification：通知功能，如果Sentinel监控的redis实例出现问题，Sentinel能通知系统管理员 另一个电脑程序等
	Automatic failover：自动失效备援功能，如果主服务器出现问题，Sentinel自动将一台从服务器变为主服务器，并且将其他从服务器配置到新主服务器，并通知应用服务新的服务地址。
	Configuration provider：配置提供者(这么说太费解),简单说就是Sentinel告知客户端当前master服务器地址，如果发生失效备援，sentinel告知客户端新的地址。
	
	天生支持分布式，分布式sentinel的好处：
		1/ 减少误报,需要多台sentinel判定master宕机
		2/ 更健壮，即使有Sentinel停止工作，依然能提供服务
	
	配置Sentinel
		redis自带了一个sentinel配置sentinel.conf，一个典型的最小配置如下：
			sentinel monitor mymaster 127.0.0.1 6379 2
			sentinel down-after-milliseconds mymaster 60000
			sentinel failover-timeout mymaster 180000
			sentinel parallel-syncs mymaster 1

			sentinel monitor resque 192.168.1.3 6380 4
			sentinel down-after-milliseconds resque 10000
			sentinel failover-timeout resque 180000
			sentinel parallel-syncs resque 5
		你只需要将master指定给sentinel即可，每个master一个不同的名字，不需要指定slave(自动识别)，sentinel会自动更新配置(附带slave信息)，每次slave提升为master 每次发现新的sentinel都会重写配置信息。
		
		
		参考文档：http://doc.redisfans.com/topic/sentinel.html
		示例：
			配置一个简单redis集群通过一台sentinel进行监控，手动杀掉master看sentinel故障迁移效果
				集群服务器分别为: 6379 6380 6381，其中6380为master另外两台为slave，配置参见“搭建redis集群”
				sentinel配置文件:
					# sentinel monitor <master-name> <ip> <redis-port> <quorum>
					sentinel monitor mymaster localhost 6379 1 # 因为只有一台sentinel,想要看到sentinel故障迁移quorum必须为1
					sentinel down-after-milliseconds mymaster 10000 # 只要服务器在10秒之内能返回一次有效回复，就认为其仍处于正常状态
					# 以上两项配置环境就可以了
			操作：
				1/ 启动三台redis，命令：redis-server redis6380.conf
				2/ 启动sentinel：redis-server sentinel.conf --sentinel
				3/ 检查
					1/状态是否正常
						root@joshua-ubuntu:/usr/local/redis-4.0.8# ps -ef|grep redis
						root       9925      1  0 18:05 ?        00:00:00 redis-server 127.0.0.1:6379
						root       9931      1  0 18:05 ?        00:00:00 redis-server 127.0.0.1:6380
						root       9940      1  0 18:05 ?        00:00:00 redis-server 127.0.0.1:6381
						root       9946   4077  0 18:05 pts/8    00:00:00 redis-server *:26379 [sentinel]
						root       9964   5743  0 18:06 pts/9    00:00:00 grep --color=auto redis
						
					2/查看三台redis的replication信息
						root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6379 info replication
						# Replication
						role:master
						connected_slaves:2
						slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=0
						slave1:ip=127.0.0.1,port=6381,state=online,offset=42,lag=0
						master_replid:fbb11fa0e5b5c0682aa9e078abecc4cb6a06d0db
						master_replid2:0000000000000000000000000000000000000000
						master_repl_offset:42
						second_repl_offset:-1
						repl_backlog_active:1
						repl_backlog_size:1048576
						repl_backlog_first_byte_offset:1
						repl_backlog_histlen:42
						
						root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6380 info replication
						# Replication
						role:slave
						master_host:127.0.0.1
						master_port:6379
						master_link_status:up
						master_last_io_seconds_ago:7
						master_sync_in_progress:0
						slave_repl_offset:56
						slave_priority:90
						slave_read_only:1
						connected_slaves:0
						master_replid:fbb11fa0e5b5c0682aa9e078abecc4cb6a06d0db
						master_replid2:0000000000000000000000000000000000000000
						master_repl_offset:56
						second_repl_offset:-1
						repl_backlog_active:1
						repl_backlog_size:1048576
						repl_backlog_first_byte_offset:1
						repl_backlog_histlen:56
						
						root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6381 info replication
						# Replication
						role:slave
						master_host:127.0.0.1
						master_port:6379
						master_link_status:up
						master_last_io_seconds_ago:1
						master_sync_in_progress:0
						slave_repl_offset:70
						slave_priority:100
						slave_read_only:1
						connected_slaves:0
						master_replid:fbb11fa0e5b5c0682aa9e078abecc4cb6a06d0db
						master_replid2:0000000000000000000000000000000000000000
						master_repl_offset:70
						second_repl_offset:-1
						repl_backlog_active:1
						repl_backlog_size:1048576
						repl_backlog_first_byte_offset:1
						repl_backlog_histlen:70
						
						root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 26379 info sentinel
						# Sentinel
						sentinel_masters:1
						sentinel_tilt:0
						sentinel_running_scripts:0
						sentinel_scripts_queue_length:0
						sentinel_simulate_failure_flags:0
						master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=1
				
				4/ 状态OK， 手动停掉6379(redis-cli -p 6379 shutdown) 看sentinel(26379)故障迁移消息
					root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-server sentinel.conf --sentinel
					10516:X 28 Mar 18:32:24.867 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
					10516:X 28 Mar 18:32:24.867 # Redis version=4.0.8, bits=64, commit=00000000, modified=0, pid=10516, just started
					10516:X 28 Mar 18:32:24.867 # Configuration loaded
					10516:X 28 Mar 18:32:24.869 * Increased maximum number of open files to 10032 (it was originally set to 1024).
					                _._                                                  
					           _.-``__ ''-._                                             
					      _.-``    `.  `_.  ''-._           Redis 4.0.8 (00000000/0) 64 bit
					  .-`` .-```.  ```\/    _.,_ ''-._                                   
					 (    '      ,       .-`  | `,    )     Running in sentinel mode
					 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
					 |    `-._   `._    /     _.-'    |     PID: 10516
					  `-._    `-._  `-./  _.-'    _.-'                                   
					 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
					 |    `-._`-._        _.-'_.-'    |           http://redis.io        
					  `-._    `-._`-.__.-'_.-'    _.-'                                   
					 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
					 |    `-._`-._        _.-'_.-'    |                                  
					  `-._    `-._`-.__.-'_.-'    _.-'                                   
					      `-._    `-.__.-'    _.-'                                       
					          `-._        _.-'                                           
					              `-.__.-'                                               

					10516:X 28 Mar 18:32:24.872 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
					10516:X 28 Mar 18:32:24.876 # Sentinel ID is b10301d9665ffac7336da33548d522a9d1365a84
					10516:X 28 Mar 18:32:24.876 # +monitor master mymaster 127.0.0.1 6379 quorum 1
					10516:X 28 Mar 18:32:24.878 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:32:24.882 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379


					123^H^H^H^H

					10516:X 28 Mar 18:40:55.993 # +sdown master mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:55.994 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1
					10516:X 28 Mar 18:40:55.997 # +new-epoch 1
					10516:X 28 Mar 18:40:55.997 # +try-failover master mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.003 # +vote-for-leader b10301d9665ffac7336da33548d522a9d1365a84 1
					10516:X 28 Mar 18:40:56.004 # +elected-leader master mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.004 # +failover-state-select-slave master mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.094 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.094 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.179 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.343 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.344 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:56.383 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:57.331 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:57.332 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:57.394 # +failover-end master mymaster 127.0.0.1 6379
					10516:X 28 Mar 18:40:57.395 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380
					10516:X 28 Mar 18:40:57.396 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380
					10516:X 28 Mar 18:40:57.396 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380
					10516:X 28 Mar 18:41:07.411 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380
					
					# 整理一下shutdown 6379 后，sentinel(26379)大概做了什么
						1/ sentinel sdown 6379. 主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断
						2/ 几乎同时 sentinel odown 6379. 客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）
							因为只有一台sentinel且配置(# sentinel monitor <master-name> <ip> <redis-port> <quorum>)中quorum=1。
						3/ try-failover尝试故障迁移
						4/ vote-for-leader 投票选出进行故障迁移的机器
						下边是sentinel进行具体故障迁移的步骤
						5/ failover-state-send-slaveof-noone # 6380设置slaveof-noone
						6/ promoted-slave slave 127.0.0.1:6380 # 提升6380为master
						7/ failover-state-reconf-slaves master mymaster # 重新配置mymaster
						8/ slave-reconf-sent slave 127.0.0.1:6381 # 6381配置为6380的slave
						9/ switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380 # mymaster的master 6379-->6380
						10/ 6379 6381 配置为6380的slave
						11/ sdown 6379
					
					此时可以再查看下info sentinel 
						root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 26379 info sentinel
						# Sentinel
						sentinel_masters:1
						sentinel_tilt:0
						sentinel_running_scripts:0
						sentinel_scripts_queue_length:0
						sentinel_simulate_failure_flags:0
						master0:name=mymaster,status=ok,address=127.0.0.1:6380,slaves=2,sentinels=1
						mymaster已经变为127.0.0.1:6380
					
					也可以看各redis的replication信息进行验证
					root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6380 info replication
					# Replication
					role:master
					connected_slaves:1
					slave0:ip=127.0.0.1,port=6381,state=online,offset=35627,lag=0
					master_replid:a834dcb1318d021ef56af81d777b1c35341dfdf4
					master_replid2:fbb11fa0e5b5c0682aa9e078abecc4cb6a06d0db
					master_repl_offset:35627
					second_repl_offset:33169
					repl_backlog_active:1
					repl_backlog_size:1048576
					repl_backlog_first_byte_offset:1
					repl_backlog_histlen:35627
					root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6381 info replication
					# Replication
					role:slave
					master_host:127.0.0.1
					master_port:6380
					master_link_status:up
					master_last_io_seconds_ago:2
					master_sync_in_progress:0
					slave_repl_offset:36040
					slave_priority:100
					slave_read_only:1
					connected_slaves:0
					master_replid:a834dcb1318d021ef56af81d777b1c35341dfdf4
					master_replid2:fbb11fa0e5b5c0682aa9e078abecc4cb6a06d0db
					master_repl_offset:36040
					second_repl_offset:33169
					repl_backlog_active:1
					repl_backlog_size:1048576
					repl_backlog_first_byte_offset:1
					repl_backlog_histlen:36040
					root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6379 info replication
					Could not connect to Redis at 127.0.0.1:6379: Connection refused
					
					重新启动6379 会发现6379变为6380的slave
						10516:X 28 Mar 19:05:01.635 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380
					注意看一下redis的配置文件，会发现配置文件已经更改，这里不展开说了
			sentinel间通信
				被sentinel管理的redis都接收sentinel的"__sentinel__:hello", sentinel每秒钟发送一次消息
				root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6379 PUBSUB CHANNELS 
				1) "__sentinel__:hello"
				root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6380 PUBSUB CHANNELS 
				1) "__sentinel__:hello"
				root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli -p 6381 PUBSUB CHANNELS 
				1) "__sentinel__:hello"
				root@joshua-ubuntu:/usr/local/redis-4.0.8# redis-cli
				127.0.0.1:6379> SUBSCRIBE __sentinel__:hello
				Reading messages... (press Ctrl-C to quit)
				1) "subscribe"
				2) "__sentinel__:hello"
				3) (integer) 1
				1) "message"
				2) "__sentinel__:hello"
				3) "127.0.0.1,26379,b10301d9665ffac7336da33548d522a9d1365a84,1,mymaster,127.0.0.1,6380,1"
				1) "message"
				2) "__sentinel__:hello"
				3) "127.0.0.1,26379,b10301d9665ffac7336da33548d522a9d1365a84,1,mymaster,127.0.0.1,6380,1"
				1) "message"
				2) "__sentinel__:hello"
				3) "127.0.0.1,26379,b10301d9665ffac7336da33548d522a9d1365a84,1,mymaster,127.0.0.1,6380,1"
				1) "message"
				2) "__sentinel__:hello"
				3) "127.0.0.1,26379,b10301d9665ffac7336da33548d522a9d1365a84,1,mymaster,127.0.0.1,6380,1"
				1) "message"
				2) "__sentinel__:hello"
				3) "127.0.0.1,26379,b10301d9665ffac7336da33548d522a9d1365a84,1,mymaster,127.0.0.1,6380,1"
			sentinelapi